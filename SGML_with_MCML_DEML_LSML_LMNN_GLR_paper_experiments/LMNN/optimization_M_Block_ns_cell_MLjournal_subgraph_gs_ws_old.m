function [M,...
    scaled_M,...
    scaled_factors,...
    M_current_eigenvector,...
    min_objective,...
    bins,...
    invalid_result,...
    time_lp,...
    time_gs,...
    time_grad,...
    time_sf,...
    time_ds,...
    num_list] = optimization_M_Block_ns_cell_MLjournal_subgraph_gs_ws_old(current_node,league_vec,league_vec_temp,flip_number,...
    Ms_off_diagonal,...
    scaled_factors_v,...
    scaled_factors_h,...
    feature_N,...
    G,...
    M21,...
    M,...
    BCD,...
    M_current_eigenvector,...
    partial_feature,...
    x,...
    rho,...
    S_upper,...
    scaled_M,...
    scaled_factors,...
    bins,...
    objective_previous,...
    lobpcg_random_control,...
    tol_golden_search,...
    time_lp,...
    time_gs,...
    time_grad,...
    time_sf,...
    time_ds,...
    time_i,...
    nv,...
    zz,...
    targets_ind,...
    same_label,...
    partial_sample,...
    num_list)

tol_offdia=Inf;
counter=0;
M_temp_best=M;
objective_previous_temp=objective_previous;

%% LP settings that do not have to be set in every Frank-Wolfe iteration starts
ddd = (0 - rho - sum(abs(Ms_off_diagonal),2));

%LP_A = zeros(1+feature_N,feature_N-1+feature_N);
LP_A_sparse_i=zeros(1,feature_N-1+1+2*(feature_N-1)+feature_N);
LP_A_sparse_j=LP_A_sparse_i;
LP_A_sparse_s=LP_A_sparse_i;

LP_b = zeros(1+feature_N,1);
sign_vecdd = flip_number'*current_node*-1;

%LP_A(1,1:feature_N-1)=sign_vecdd.*abs(scaled_factors_h);
%LP_A(1,feature_N-1+BCD)=-1;
LP_A_sparse_i(1:feature_N-1)=1;
LP_A_sparse_j(1:feature_N-1)=1:feature_N-1;
LP_A_sparse_s(1:feature_N-1)=sign_vecdd.*abs(scaled_factors_h);
LP_A_sparse_i(feature_N)=1;
LP_A_sparse_j(feature_N)=feature_N-1+BCD;
LP_A_sparse_s(feature_N)=-1;

LP_b(1)=-rho;
scaler_v = abs(scaled_factors_v);

remaining_idx = 1:feature_N;
remaining_idx(BCD)=[];
for LP_A_i=1:feature_N-1
    %LP_A(LP_A_i+1,LP_A_i)=sign_vecdd(1,LP_A_i)*scaler_v(LP_A_i);
    %LP_A(LP_A_i+1,feature_N-1+remaining_idx(LP_A_i))=-1;
    temp_index=feature_N+(LP_A_i-1)*2+1;
    temp_index1=feature_N+(LP_A_i-1)*2+2;
    LP_A_sparse_i(temp_index)=LP_A_i+1;
    LP_A_sparse_j(temp_index)=LP_A_i;
    LP_A_sparse_s(temp_index)=sign_vecdd(1,LP_A_i)*scaler_v(LP_A_i);
    LP_A_sparse_i(temp_index1)=LP_A_i+1;
    LP_A_sparse_j(temp_index1)=feature_N-1+remaining_idx(LP_A_i);
    LP_A_sparse_s(temp_index1)=-1;
    LP_b(LP_A_i+1)=ddd(LP_A_i);
end
%LP_A(end,feature_N-1+1:end)=1;
temp_index=feature_N-1+1+2*(feature_N-1)+1;
LP_A_sparse_i(temp_index:end)=feature_N+1;
LP_A_sparse_j(temp_index:end)=feature_N-1+1:feature_N-1+feature_N;
LP_A_sparse_s(temp_index:end)=1;

LP_A = sparse(LP_A_sparse_i,LP_A_sparse_j,LP_A_sparse_s,1+feature_N,feature_N-1+feature_N);

LP_b(end)=S_upper;

LP_lb=zeros(feature_N-1+feature_N,1);
LP_ub=zeros(feature_N-1+feature_N,1);

for LP_lb_i=1:feature_N-1
    if sign(sign_vecdd(LP_lb_i))==-1 %<0
        LP_lb(LP_lb_i)=-Inf;
        LP_ub(LP_lb_i)=0;
    else %>0
        LP_lb(LP_lb_i)=0;
        LP_ub(LP_lb_i)=Inf;
    end
end

zero_mask=ones(2*feature_N-1,1);
lu_bound_idx=scaler_v==0;
LP_lb(lu_bound_idx)=0;
LP_ub(lu_bound_idx)=0;
zero_mask(lu_bound_idx)=0;
% for LP_lb_i=1:feature_N-1
%     if scaler_v(LP_lb_i)==0
%         LP_lb(LP_lb_i)=0;
%         LP_ub(LP_lb_i)=0;
%         zero_mask(LP_lb_i)=0;
%     end
% end

LP_lb(feature_N-1+1:end)=rho;
LP_ub(feature_N-1+1:end)=Inf;

LP_Aeq = [];
LP_beq = [];

options = optimoptions('linprog','Display','none','Algorithm','dual-simplex');
options.OptimalityTolerance = 1e-2;
options.ConstraintTolerance = 1e-4;
%% LP settings that do not have to be set in every Frank-Wolfe iteration ends
while tol_offdia>1e-5
    
    %     remaining_idx=1:feature_N;
    %     remaining_idx(remaining_idx==BCD)=[];
    %     lp_co = [2*G(remaining_idx,BCD);diag(G)];
    
    tic;
    s_k = linprog(G,...
        LP_A,LP_b,...
        LP_Aeq,LP_beq,...
        LP_lb,LP_ub,options);
    time_lp(time_i)=time_lp(time_i)+toc;
    
    while isempty(s_k) == 1
        disp('===trying with larger OptimalityTolerance===');
        options.OptimalityTolerance = options.OptimalityTolerance*10;
        tic;
        s_k = linprog(G,...
            LP_A,LP_b,...
            LP_Aeq,LP_beq,...
            LP_lb,LP_ub,options);
        time_lp(time_i)=time_lp(time_i)+toc;
    end
    %% set a step size
    if isequal(league_vec,league_vec_temp)==1
        
        M_previous=zeros(feature_N-1+feature_N,1);
        M_previous(1:feature_N-1)=M_temp_best(BCD,remaining_idx);
        M_previous(feature_N-1+1:end)=M_temp_best(logical(eye(feature_N)));
        t_M21_solution_previous=s_k - M_previous;
        
        tic;
        %% GS starts
%         [gamma] = optimization_M_golden_section_search(...
%             0,...
%             1,...
%             M_previous,...
%             t_M21_solution_previous,...
%             M_temp_best,...
%             partial_feature,...
%             x,...
%             feature_N,...
%             BCD,...
%             tol_golden_search,...
%             zero_mask,...
%             0,...
%             0,...
%             partial_sample,...
%             c,...
%             targets_ind,...
%             same_label);
        %% GS ends
        %% GD starts
        M_lc=M_temp_best;
        %% examine the gradient at 0 and 1
        [G_0] = optimization_M_gamma_M_lc(...
            M_previous,...
            0,...
            t_M21_solution_previous,...
            zero_mask,...
            remaining_idx,...
            BCD,...
            feature_N,...
            partial_feature,...
            M_lc,...
            x,...
            zz,...
            nv,...
            partial_sample,...
            targets_ind,...
            same_label);
        [G_1] = optimization_M_gamma_M_lc(...
            M_previous,...
            1,...
            t_M21_solution_previous,...
            zero_mask,...
            remaining_idx,...
            BCD,...
            feature_N,...
            partial_feature,...
            M_lc,...
            x,...
            zz,...
            nv,...
            partial_sample,...
            targets_ind,...
            same_label);
        if G_0<=0 && G_1<=0 % fmin=f(gamma=1)
            gamma=1;
        elseif G_0>=0 && G_1>=0 % fmin=f(gamma=0)
            gamma=0;
        else % fmin=f(gamma\in[0,1])
            gL=0;
            gU=1;
            nn=0;
            while abs(gL-gU)>1e-5
                nn=nn+1;
                gamma=(gL+gU)/2;
                [G_gM] = optimization_M_gamma_M_lc(...
                    M_previous,...
                    gamma,...
                    t_M21_solution_previous,...
                    zero_mask,...
                    remaining_idx,...
                    BCD,...
                    feature_N,...
                    partial_feature,...
                    M_lc,...
                    x,...
                    zz,...
                    nv,...
                    partial_sample,...
                    targets_ind,...
                    same_label);
                if G_gM>0 % fmin=f(gamma\in[gL,gamma])
                    gU=gamma;
                    gamma=(gL+gU)/2;
                    [G_gM] = optimization_M_gamma_M_lc(...
                        M_previous,...
                        gamma,...
                        t_M21_solution_previous,...
                        zero_mask,...
                        remaining_idx,...
                        BCD,...
                        feature_N,...
                        partial_feature,...
                        M_lc,...
                        x,...
                        zz,...
                        nv,...
                        partial_sample,...
                        targets_ind,...
                        same_label);
                elseif G_gM<0 % fmin=f(gamma\in[gamma,gU])
                    gL=gamma;
                    gamma=(gL+gU)/2;
                    [G_gM] = optimization_M_gamma_M_lc(...
                        M_previous,...
                        gamma,...
                        t_M21_solution_previous,...
                        zero_mask,...
                        remaining_idx,...
                        BCD,...
                        feature_N,...
                        partial_feature,...
                        M_lc,...
                        x,...
                        zz,...
                        nv,...
                        partial_sample,...
                        targets_ind,...
                        same_label);
                else % G_gM=0
                    gamma=gM;
                    break
                end
            end
        end
        %% GD ends
        time_gs(time_i)=time_gs(time_i)+toc;
        
        t_M21 = M_previous + gamma * t_M21_solution_previous;
        t_M21 = t_M21.*zero_mask;
        
        remaining_idx=1:feature_N;
        remaining_idx(BCD)=[];
        M_updated=M_temp_best;
        M_updated(BCD,remaining_idx)=t_M21(1:feature_N-1);
        M_updated(remaining_idx,BCD)=M_updated(BCD,remaining_idx);
        M_updated(logical(eye(feature_N)))=t_M21(feature_N-1+1:end);
    else
        gamma = 1;
        M_previous=zeros(feature_N-1+feature_N,1);
        M_previous(1:feature_N-1)=M_temp_best(BCD,remaining_idx);
        M_previous(feature_N-1+1:end)=M_temp_best(logical(eye(feature_N)));
        t_M21_solution_previous=s_k - M_previous;
        M21_updated = M_previous + gamma * t_M21_solution_previous;
        M21_updated=M21_updated.*zero_mask;
        
        M_updated = M_temp_best;
        M_updated(remaining_idx,BCD)=M21_updated(1:feature_N-1);
        M_updated(BCD,remaining_idx)=M_updated(remaining_idx,BCD);
        M_updated(logical(eye(feature_N)))=M21_updated(feature_N-1+1:end);
        min_objective = lmnn_obj(targets_ind,same_label,M_updated,partial_feature,partial_sample);
        
        %% reject the result (reject the color change) if it is larger than previous
        if min_objective>objective_previous_temp
            min_objective=objective_previous_temp;
            invalid_result=0;
            return
            %% there is no need to iterate, since the node color is changed
        else
            invalid_result=0;
            M_temp_best = M_updated;
            
            break % no need to iterate, not even once, otherwise it is wrong.
        end
    end
    
    %% evaluate the objective value
    min_objective = lmnn_obj(targets_ind,same_label,M_updated,partial_feature,partial_sample);
    
    invalid_result=0;
    
    M_temp_best = M_updated;
    
    %% choose the M_temp_best that has not been thresholded to compute the gradient
    tic;
    [G] = lmnn_gradient(targets_ind,...
        same_label,...
        M_temp_best,...
        partial_feature,...
        partial_sample,...
        feature_N,...
        zz,...
        BCD,...
        remaining_idx,...
        nv);
    time_grad(time_i)=time_grad(time_i)+toc;
    
    tol_offdia=norm(min_objective-objective_previous_temp);
    
    objective_previous_temp=min_objective;
    
    counter=counter+1;
    
end

M_temp_best(abs(M_temp_best)<1e-5)=0;

tic;
%% detect subgraphs
bins_temp=bins;
if sum(abs(M_temp_best(BCD,remaining_idx)))==0 % disconnected
    bins_temp(BCD)=max(bins_temp)+1; % assign a subgraph number
    M_current_eigenvector(num_list==BCD)=[]; % heuristicaly remove the 1st entry of M_current_eigenvector as the lobpcg warm start
    num_list(num_list==BCD)=[];
    M_current_eigenvector=M_current_eigenvector/sqrt(sum(M_current_eigenvector.^2));
end
time_ds(time_i)=time_ds(time_i)+toc;

%% evaluate the temporarily accepted result with temporary scaled_M and scaled_factors
tic;
scaled_M_=diag(diag(M_temp_best));
scaled_factors_=eye(feature_N);


bins_i=1;
M_updated_current = M_temp_best(bins_temp==bins_i,bins_temp==bins_i);
temp_dim = size(M_updated_current,1);

rng(lobpcg_random_control);
[M_current_eigenvector,~] = ...
    optimization_M_lobpcg(M_current_eigenvector,M_updated_current,1e-4,200);
%norm(M_temp_best*M_current_eigenvector-ld*M_current_eigenvector)
scaling_matrix_0 = diag(1./M_current_eigenvector(:,1));
scaling_matrix_0_inv = diag(M_current_eigenvector(:,1));
scaled_M_0 = scaling_matrix_0 * M_updated_current * scaling_matrix_0_inv;
scaled_factors_0 = scaling_matrix_0 * ones(temp_dim) * scaling_matrix_0_inv;

scaled_M_(bins_temp==bins_i,bins_temp==bins_i)=scaled_M_0;
scaled_factors_(bins_temp==bins_i,bins_temp==bins_i)=scaled_factors_0;

time_sf(time_i)=time_sf(time_i)+toc;

scaled_M__=scaled_M_;
scaled_M__(logical(eye(size(M_temp_best,1))))=0;
lower_bounds = sum(abs(scaled_M__),2)+rho;

%% reject the result if the lower_bounds are larger than S_upper
if sum(lower_bounds) > S_upper
    invalid_result=1;
    min_objective=objective_previous;
    %disp(['lower bounds sum:' num2str(sum(lower_bounds))]);
    %disp('========lower bounds sum larger than S_upper!!!========');
    return
end

%% M_temp_best passes all tests, now update the results
bins=bins_temp;
M=M_temp_best;
scaled_M=scaled_M_;
scaled_factors=scaled_factors_;
end

