function [M,...
    scaled_M,...
    scaled_factors,...
    bins,...
    min_objective,...
    time_lp,...
    time_gs,...
    time_grad] = optimization_M_ns_cell_MLjournal_subgraph_FULL_gs(partial_feature,league_vec,...
    scaled_M,...
    bins,...
    scaled_factors,...
    feature_N,...
    G,...
    M,...
    x,...
    rho,...
    lobpcg_random_control,...
    tol_golden_search,...
    objective_previous,...
    S_upper,...
    time_lp,...
    time_gs,...
    time_grad,...
    time_i,...
    nv,...
    zz,...
    c,...
    y,...
    partial_sample)

tol_full=Inf;
counter=0;
M_best_temp=M;
objective_previous_temp=objective_previous;

remaining_idx=[];
BCD=[];

%% LP settings that do not have to be set in every Frank-Wolfe iteration starts
scaled_factors_ = scaled_factors';
scaled_factors_(logical(eye(feature_N)))=[];
scaled_factors__ = reshape(scaled_factors_,feature_N-1,feature_N)';

total_offdia = sum(1:feature_N-1);

%LP_A = zeros(1+feature_N,total_offdia+feature_N);
%LP_A(1,total_offdia+1:end)= 1;
LP_A_sparse_i=zeros(1,feature_N^2+feature_N);
LP_A_sparse_j=LP_A_sparse_i;
LP_A_sparse_s=LP_A_sparse_i;

LP_A_sparse_i(1:feature_N)=1;
LP_A_sparse_j(1:feature_N)=total_offdia+1:total_offdia+feature_N;
LP_A_sparse_s(1:feature_N)=1;

LP_b = [S_upper;zeros(feature_N,1)-rho];

LP_lb=zeros(total_offdia+feature_N,1);
LP_ub=zeros(total_offdia+feature_N,1)+Inf;
LP_lb(total_offdia+1:end)=rho;

t_counter=0;
t_counter_c=0;
sign_vec=zeros(1,total_offdia);
sign_idx=zeros(feature_N);
scaled_factors_zero_idx = zeros(1,total_offdia);
for vec_i=1:feature_N
    for vec_j=1:feature_N
        if vec_j>vec_i
            t_counter=t_counter+1;
            if league_vec(vec_i)==league_vec(vec_j) % positive edge, negative m entry <0
                sign_vec(t_counter)=-1;
                LP_lb(t_counter)=-Inf;
                LP_ub(t_counter)=0;
            else
                sign_vec(t_counter)=1;
                LP_lb(t_counter)=0;
                LP_ub(t_counter)=Inf;
            end
            
            if scaled_factors(vec_i,vec_j)==0
                scaled_factors_zero_idx(t_counter)=1;
            end
            
        end
        t_counter_c=t_counter_c+1;
        sign_idx(vec_i,t_counter_c)=t_counter;
    end
    t_counter_c=0;
end

%% fixing the off-diagonals to be 0's
LP_lb(logical(scaled_factors_zero_idx))=0;
LP_ub(logical(scaled_factors_zero_idx))=0;

zero_mask=ones(total_offdia+feature_N,1);
zero_mask(logical(scaled_factors_zero_idx))=0;

sign_idx=triu(sign_idx,1);
sign_idx=sign_idx+sign_idx';
sign_idx(logical(eye(feature_N)))=[];
sign_idx=reshape(sign_idx,feature_N-1,feature_N)';

for LP_i=1:feature_N
    %LP_A(1+LP_i,sign_idx(LP_i,:))=abs(scaled_factors__(LP_i,:)).*sign_vec(sign_idx(LP_i,:));
    %LP_A(1+LP_i,total_offdia+LP_i)=-1;
    temp_index=feature_N+(LP_i-1)*feature_N+1:feature_N+LP_i*feature_N-1;
    temp_index1=feature_N+LP_i*feature_N;
    LP_A_sparse_i(temp_index)=1+LP_i;
    LP_A_sparse_i(temp_index1)=1+LP_i;
    LP_A_sparse_j(temp_index)=sign_idx(LP_i,:);
    LP_A_sparse_j(temp_index1)=total_offdia+LP_i;
    LP_A_sparse_s(temp_index)=abs(scaled_factors__(LP_i,:)).*sign_vec(sign_idx(LP_i,:));
    LP_A_sparse_s(temp_index1)=-1;
end

LP_A=sparse(LP_A_sparse_i,LP_A_sparse_j,LP_A_sparse_s,1+feature_N,total_offdia+feature_N);

LP_Aeq = [];
LP_beq = [];

options = optimoptions('linprog','Display','none','Algorithm','interior-point');
options.OptimalityTolerance = 1e-5;
%% LP settings that do not have to be set in every Frank-Wolfe iteration ends

while tol_full>1e-5
    
    net_gc=[2*G(zz);diag(G)];
    
    tic;
    s_k = linprog(net_gc,...
        LP_A,LP_b,...
        LP_Aeq,LP_beq,...
        LP_lb,LP_ub,options);
    time_lp(time_i)=time_lp(time_i)+toc;
    
    while isempty(s_k) == 1
        disp('===trying with larger OptimalityTolerance===');
        options.OptimalityTolerance = options.OptimalityTolerance*10;
        tic;
        s_k = linprog(net_gc,...
            LP_A,LP_b,...
            LP_Aeq,LP_beq,...
            LP_lb,LP_ub,options);
        time_lp(time_i)=time_lp(time_i)+toc;
    end
    
    %% proximal gradient to determine the Frank-Wolfe step size starts
    
    M_previous=[M_best_temp(zz);diag(M_best_temp)];
    
    t_M21_solution_previous=s_k - M_previous;
    
    tic;
    %     [gamma] = optimization_M_golden_section_search(...
    %         0,...
    %         1,...
    %         M_previous,...
    %         t_M21_solution_previous,...
    %         M_best_temp,...
    %         partial_feature,...
    %         x,...
    %         feature_N,...
    %         0,...
    %         tol_golden_search,...
    %         zero_mask,...
    %         zz,...
    %         total_offdia,...
    %         partial_sample,...
    %         c);
    M_lc=M_best_temp;
    %% examine the gradient at 0 and 1
    [G_0] = optimization_M_gamma_M_lc(...
        M_previous,...
        0,...
        t_M21_solution_previous,...
        zero_mask,...
        remaining_idx,...
        BCD,...
        feature_N,...
        partial_feature,...
        M_lc,...
        x,...
        zz,...
        nv,...
        partial_sample,...
        c,...
        y);
    [G_1] = optimization_M_gamma_M_lc(...
        M_previous,...
        1,...
        t_M21_solution_previous,...
        zero_mask,...
        remaining_idx,...
        BCD,...
        feature_N,...
        partial_feature,...
        M_lc,...
        x,...
        zz,...
        nv,...
        partial_sample,...
        c,...
        y);
    if G_0<=0 && G_1<=0 % fmin=f(gamma=1)
        gamma=1;
    elseif G_0>=0 && G_1>=0 % fmin=f(gamma=0)
        gamma=0;
    else % fmin=f(gamma\in[0,1])
        gL=0;
        gU=1;
        nn=0;
        while abs(gL-gU)>1e-5
            nn=nn+1;
            gamma=(gL+gU)/2;
            [G_gM] = optimization_M_gamma_M_lc(...
                M_previous,...
                gamma,...
                t_M21_solution_previous,...
                zero_mask,...
                remaining_idx,...
                BCD,...
                feature_N,...
                partial_feature,...
                M_lc,...
                x,...
                zz,...
                nv,...
                partial_sample,...
                c,...
                y);
            if G_gM>0 % fmin=f(gamma\in[gL,gamma])
                gU=gamma;
                gamma=(gL+gU)/2;
                [G_gM] = optimization_M_gamma_M_lc(...
                    M_previous,...
                    gamma,...
                    t_M21_solution_previous,...
                    zero_mask,...
                    remaining_idx,...
                    BCD,...
                    feature_N,...
                    partial_feature,...
                    M_lc,...
                    x,...
                    zz,...
                    nv,...
                    partial_sample,...
                    c,...
                    y);
            elseif G_gM<0 % fmin=f(gamma\in[gamma,gU])
                gL=gamma;
                gamma=(gL+gU)/2;
                [G_gM] = optimization_M_gamma_M_lc(...
                    M_previous,...
                    gamma,...
                    t_M21_solution_previous,...
                    zero_mask,...
                    remaining_idx,...
                    BCD,...
                    feature_N,...
                    partial_feature,...
                    M_lc,...
                    x,...
                    zz,...
                    nv,...
                    partial_sample,...
                    c,...
                    y);
            else % G_gM=0
                gamma=gM;
                break
            end
        end
    end
    time_gs(time_i)=time_gs(time_i)+toc;
    
    t_M21 = M_previous + gamma * t_M21_solution_previous;
    t_M21 = t_M21.*zero_mask;
    M_updated=M_best_temp;
    M_updated(zz)=t_M21(1:total_offdia);
    M_updated_t=M_updated';
    M_updated(zz')=M_updated_t(zz');
    
    M_updated(logical(eye(feature_N)))=t_M21(total_offdia+1:end);
    
    %% evaluate the objective value
    [ L_c ] = optimization_M_set_L_Mahalanobis( partial_sample, c, M_updated );
    min_objective = x' * L_c * x;
    
    M_best_temp = M_updated;
    
    %% choose the M_best_temp that has not been thresholded to compute the gradient
    tic;
    [ G ] = optimization_M_set_gradient( partial_sample, feature_N, c, M_best_temp, y, nv, 0);
    time_grad(time_i)=time_grad(time_i)+toc;
    
    tol_full=norm(min_objective-objective_previous_temp);
    
    objective_previous_temp=min_objective;
    
    counter=counter+1;
    
end
M=M_best_temp;
end

